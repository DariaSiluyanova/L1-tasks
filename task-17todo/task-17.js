// Необходимо реализовать простое поле ввода адреса с функцией геокодинга:
// пользователь вводит данные в поле с помощью одного из геоинформационных
// сервисов (Яндекс.Карты, ДаДата, GraphHopper), подбирается адрес. Найденные
// данные должны отображаться в выпадающем списке, из которого можно
// выбрать подходящее значение.
// Реализовать дебоунсинг и защиту от троттлинга с помощью замыканий.

// Реализация дебаунсинга взята с https://doka.guide/js/debounce/

const searchForm = document.getElementById("search")
const searchInput = searchForm.querySelector('geo');
const searchResults = document.querySelector('.search-results');

ymaps = window.ymaps


function init() {
    let suggestAddress = new ymaps.SuggestView('geo');
} 
const debounceHandle = debounce(ymaps.ready(init), 250)


/**
 * функция, откладывающая запрос на сервер пока пользователь не введет что-нибудь
 * @param {*} callee, функция, которую нужно отложить
 * @param {*} timeoutMs, интервал времени, спустя которое нужно вызвать функцию calee
 * @returns {function}
 */
// Аргументами функции будут:
// - функция, которую надо «откладывать»;
// - интервал времени, спустя которое функцию следует вызывать.
function debounce(callee, timeoutMs) {
    // Как результат возвращаем другую функцию.
    // Это нужно, чтобы мы могли не менять другие части кода,
    // чуть позже мы увидим, как это помогает.
    return function perform(...args) {
      // В переменной previousCall мы будем хранить
      // временную метку предыдущего вызова...
      let previousCall = this.lastCall
  
      // ...а в переменной текущего вызова —
      // временную метку нынешнего момента.
      this.lastCall = Date.now()
  
      // Нам это будет нужно, чтобы потом сравнить,
      // когда была функция вызвана в этот раз и в предыдущий.
      // Если разница между вызовами меньше, чем указанный интервал,
      // то мы очищаем таймаут...
      if (previousCall && this.lastCall - previousCall <= timeoutMs) {
        clearTimeout(this.lastCallTimer)
      }
  
      // ...который отвечает за непосредственно вызов функции-аргумента.
      // Обратите внимание, что мы передаём все аргументы ...args,
      // который получаем в функции perform —
      // это тоже нужно, чтобы нам не приходилось менять другие части кода.
      this.lastCallTimer = setTimeout(() => callee(...args), timeoutMs)
  
      // Если таймаут был очищен, вызова не произойдёт
      // если он очищен не был, то callee вызовется.
      // Таким образом мы как бы «отодвигаем» вызов callee
      // до тех пор, пока «снаружи всё не подуспокоится».
    }
}
